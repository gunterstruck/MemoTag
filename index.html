<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#4F46E5">
    <meta name="description" content="Sprach-Tagebuch mit KI-Zusammenfassungen">
    <title>Sprach-Tagebuch Pro</title>
    <link rel="manifest" href="manifest.webmanifest">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
        }

        .header {
            background: white;
            border-radius: 20px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        h1 {
            color: #4F46E5;
            font-size: 28px;
            margin-bottom: 15px;
            overflow-wrap: break-word;
        }

        .api-setup {
            background: #F3F4F6;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
        }

        .input-group {
            margin-bottom: 10px;
        }

        label {
            display: block;
            font-size: 14px;
            color: #374151;
            margin-bottom: 5px;
            font-weight: 500;
        }

        input[type="text"], input[type="password"], select, textarea {
            width: 100%;
            padding: 10px;
            border: 2px solid #E5E7EB;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #4F46E5;
        }
        
        .record-section {
            background: white;
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            text-align: center;
        }

        .record-button {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
            font-size: 48px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 20px auto;
        }

        .record-button:hover {
            transform: scale(1.05);
        }

        .record-button:focus {
            outline: 3px solid #818CF8;
            outline-offset: 3px;
        }

        .record-button.recording {
            background: linear-gradient(135deg, #EF4444 0%, #DC2626 100%);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .status {
            font-size: 16px;
            color: #6B7280;
            margin-top: 10px;
        }

        .transcript-section, .summary-section {
            background: white;
            border-radius: 20px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            opacity: 0;
            height: 0;
            overflow: hidden;
            transition: opacity 0.5s ease-in-out, height 0.5s ease-in-out;
            pointer-events: none;
        }

        .transcript-section.show, .summary-section.show {
            opacity: 1;
            height: auto;
            pointer-events: all;
        }

        .section-title {
            font-size: 18px;
            color: #4F46E5;
            margin-bottom: 15px;
            font-weight: 600;
        }

        textarea {
            min-height: 150px;
            resize: vertical;
            font-family: inherit;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 20px;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

        button:focus {
            outline: 2px solid #4F46E5;
            outline-offset: 2px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            flex: 1;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #F3F4F6;
            color: #374151;
            flex: 1;
        }

        .btn-secondary:hover {
            background: #E5E7EB;
        }

        .btn-icon {
            background: #F3F4F6;
            color: #374151;
            padding: 10px 15px;
            flex: 1;
        }

        .btn-icon:hover {
            background: #E5E7EB;
        }

        .tags-section {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 2px solid #F3F4F6;
        }
        
        /* Neuer Stil f√ºr Tag-Vorschl√§ge */
        .available-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
            margin-bottom: 15px;
            padding: 10px;
            background: #F9FAFB;
            border-radius: 8px;
        }
        
        .tag-suggestion {
            background: #E0E7FF;
            color: #4F46E5;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 13px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }
        
        .tag-suggestion:hover {
            background: #C7D2FE;
        }
        
        .tag-suggestion.active {
            background: #4F46E5;
            color: white;
            border-color: #4F46E5;
        }


        .tags-input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .tags-input-group input {
            flex: 1;
        }

        .tags-input-group button {
            flex: 0 0 auto;
        }

        .tag-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .tag {
            background: #EEF2FF;
            color: #4F46E5;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .tag-remove {
            background: none;
            border: none;
            color: #4F46E5;
            cursor: pointer;
            padding: 0;
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            font-size: 12px;
        }

        .tag-remove:hover {
            background: #4F46E5;
            color: white;
        }

        .reformulate-section {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 2px solid #F3F4F6;
        }

        .reformulate-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .entries-section {
            background: white;
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .entries-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .tag-filter {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        .filter-tag {
            background: #F3F4F6;
            color: #374151;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 13px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.3s;
        }

        .filter-tag:hover {
            background: #E5E7EB;
        }

        .filter-tag.active {
            background: #4F46E5;
            color: white;
            border-color: #4F46E5;
        }

        .selection-mode-btn {
            background: #4F46E5;
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 14px;
        }

        .batch-actions {
            display: none;
            background: #FEF3C7;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            gap: 10px;
            flex-wrap: wrap;
        }

        .batch-actions.show {
            display: flex;
        }

        .batch-actions button {
            flex: 0 0 auto;
            padding: 8px 16px;
            font-size: 13px;
        }

        .entry {
            background: #F9FAFB;
            padding: 15px;
            border-left: 4px solid #4F46E5;
            position: relative;
            border-radius: 10px;
            margin-bottom: 15px;
        }

        .entry.selection-mode {
            padding-left: 50px;
        }

        .entry-checkbox {
            position: absolute;
            left: 15px;
            top: 20px;
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .entry-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 10px;
            gap: 10px;
        }

        .entry-date {
            font-size: 14px;
            color: #4F46E5;
            font-weight: 600;
        }

        .entry-location {
            font-size: 12px;
            color: #6B7280;
            margin-top: 2px;
        }

        .entry-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin: 8px 0;
        }

        .entry-text {
            color: #374151;
            line-height: 1.6;
            white-space: pre-wrap;
            margin-bottom: 10px;
        }

        .entry-actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .entry-actions button {
            padding: 6px 12px;
            font-size: 12px;
        }

        .delete-btn {
            background: #EF4444;
            color: white;
        }

        .delete-btn:hover {
            background: #DC2626;
        }

        .empty-state {
            text-align: center;
            padding: 40px;
            color: #9CA3AF;
        }

        .loading {
            display: none;
            text-align: center;
            color: #6B7280;
            padding: 10px;
        }

        .loading.show {
            display: block;
        }

        .error {
            background: #FEE2E2;
            color: #991B1B;
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            display: none;
        }

        .error.show {
            display: block;
        }

        .success {
            background: #D1FAE5;
            color: #065F46;
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            display: none;
        }

        .success.show {
            display: block;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 20px;
            padding: 30px;
            max-width: 600px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .modal-close {
            background: #F3F4F6;
            border: none;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
        }

        @media (max-width: 640px) {
            body {
                padding: 10px;
            }
            
            h1 {
                font-size: 22px;
            }
            
            .button-group, .reformulate-buttons {
                flex-direction: column;
            }
            
            .btn-icon {
                flex: 1 1 100%;
            }

            .tags-input-group {
                flex-direction: column;
            }

            .tags-input-group button {
                flex: 1 1 100%;
            }
        }
    </style>

<style id="diag-styles">
  .diag-card { margin: 16px auto; max-width: 900px; background: rgba(255,255,255,0.9); border-radius: 16px; padding: 16px; box-shadow: 0 6px 24px rgba(0,0,0,0.08); }
  .diag-grid { display: grid; grid-template-columns: 160px 1fr; gap: 8px 16px; align-items: center; }
  .state-badge { display:inline-block; padding:4px 10px; border-radius:999px; font-size:12px; font-weight:600; }
  .state-ok { background:#e6f7ef; color:#0a7f4f; }
  .state-warn { background:#fff4e6; color:#a15a00; }
  .state-err { background:#ffe8e6; color:#b50000; }
  .level-wrap { width:100%; height:10px; background:#eee; border-radius:6px; overflow:hidden; }
  .level-bar { height:100%; width:0%; transition: width .08s linear; }
  .level-bar.anim { background: linear-gradient(90deg, #a78bfa, #7c3aed); }
  #diag-log { max-height: 140px; overflow:auto; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; font-size:12px; background:#fafafa; border:1px solid #eee; border-radius:8px; padding:8px; }
  #diag-log .line { padding:2px 0; border-bottom:1px dashed #eee;}
  #diag-last-error { color:#b50000; font-weight:600; }
</style>


    <link rel="apple-touch-icon" href="icon-192.png">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Sprach-Tagebuch Pro</h1>
            
            <div class="api-setup">
                <div class="input-group">
                    <label for="apiProvider">KI-Anbieter:</label>
                    <select id="apiProvider">
                        <option value="anthropic">Anthropic (Claude)</option>
                        <option value="openai">OpenAI (GPT)</option>
                        <option value="gemini">Google (Gemini)</option>
                    </select>
                </div>
                <div class="input-group">
                    <label for="apiKey">API-Schl√ºssel:</label>
                    <input type="password" id="apiKey" placeholder="Dein API-Schl√ºssel">
                </div>
                <div class="input-group">
                    <label>
                        <input type="checkbox" id="locationPermission">
                        Standort-Freigabe (optional)
                    </label>
                </div>
            </div>
        </div>

        <div class="record-section">
            <h2 class="section-title">Neue Notiz aufnehmen</h2>
            <button class="record-button" id="recordBtn" aria-label="Aufnahme starten">üé§</button>

<div style="margin-top:10px;">
    <button class="btn-secondary" id="audioBtn" aria-label="Audio aufnehmen oder ausw√§hlen">Audio aufnehmen/ausw√§hlen</button>
    <input type="file" id="audioInput" accept="audio/*" capture="microphone" style="display:none;">
    <div id="iosHint" class="status" style="display:none;">iOS erkannt: Verwende bitte ‚ÄûAudio aufnehmen/ausw√§hlen‚Äú (Live-Spracherkennung wird von Safari nicht unterst√ºtzt).</div>

<div style="margin-top:8px;">
    <button class="btn-secondary" id="pcRecordBtn" aria-label="PC: Direkt aufnehmen">PC: Direkt aufnehmen</button>
    <span id="pcRecordStatus" class="status" style="margin-left:8px;"></span>
</div>

</div>

            <div class="status" id="status" role="status" aria-live="polite">Bereit zur Aufnahme</div>
        </div>

        <div class="transcript-section" id="transcriptSection">
            <h2 class="section-title">Transkription</h2>
            <textarea id="transcript" readonly aria-label="Transkribierter Text"></textarea>
            <div class="button-group">
                <button class="btn-primary" id="summarizeBtn">Zusammenfassen</button>
                <button class="btn-secondary" id="cancelBtn">Abbrechen</button>
            </div>
            <div class="loading" id="loading" role="status">KI erstellt Zusammenfassung...</div>
            <div class="error" id="error" role="alert"></div>
        </div>

        <div class="summary-section" id="summarySection">
            <h2 class="section-title">Zusammenfassung</h2>
            <textarea id="summary" aria-label="Zusammenfassung bearbeiten"></textarea>
            
            <div class="tags-section">
                <label>Verf√ºgbare Tags:</label>
                <div class="available-tags" id="availableTags">
                    <!-- Hier werden die Tags per JavaScript eingef√ºgt -->
                </div>

                <label>Tags hinzuf√ºgen:</label>
                <div class="tags-input-group">
                    <input type="text" id="newTag" placeholder="z.B. Arbeit, Einkauf, Idee...">
                    <button class="btn-secondary" id="addTagBtn">+ Tag</button>
                </div>
                <div class="tag-list" id="currentTags"></div>
            </div>

            <div class="reformulate-section">
                <label>Neu formulieren:</label>
                <div class="reformulate-buttons">
                    <button class="btn-icon" id="reformulateShorter">K√ºrzer</button>
                    <button class="btn-icon" id="reformulateFormal">Formeller</button>
                    <button class="btn-icon" id="reformulateCasual">Lockerer</button>
                </div>
                <div class="loading" id="reformulateLoading" role="status">KI formuliert um...</div>
            </div>

            <div class="button-group">
                <button class="btn-primary" id="saveBtn">Speichern</button>
                <button class="btn-icon" id="copyBtn">Kopieren</button>
                <button class="btn-icon" id="shareBtn">Teilen</button>
                <button class="btn-secondary" id="editCancelBtn">Abbrechen</button>
            </div>
            <div class="success" id="success" role="status"></div>
        </div>

        <div class="entries-section">
            <div class="entries-header">
                <h2 class="section-title">Meine Eintr√§ge</h2>
                <button class="selection-mode-btn" id="toggleSelectionBtn">Ausw√§hlen</button>
            </div>

            <div class="batch-actions" id="batchActions">
                <button class="btn-primary" id="summarizeSelectedBtn">Gesamt-Zusammenfassung</button>
                <button class="btn-secondary" id="tagSelectedBtn">Tags setzen</button>
                <button class="btn-secondary" id="exportSelectedBtn">Exportieren</button>
                <button class="btn-secondary" id="shareSelectedBtn">Teilen</button>
                <button class="delete-btn" id="deleteSelectedBtn">L√∂schen</button>
            </div>

            <div class="tag-filter" id="tagFilter"></div>
            <div id="entries"></div>
        </div>
    </div>

    <!-- Edit Modal -->
    <div class="modal" id="editModal" role="dialog" aria-labelledby="editModalTitle">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="section-title" id="editModalTitle">Notiz bearbeiten</h2>
                <button class="modal-close" id="closeEditModal" aria-label="Schlie√üen">‚úï</button>
            </div>
            <textarea id="editText" aria-label="Text bearbeiten"></textarea>
            <div class="tags-section">
                <label>Verf√ºgbare Tags:</label>
                <div class="available-tags" id="editAvailableTags">
                    <!-- Hier werden die Tags per JavaScript eingef√ºgt -->
                </div>
                <label>Tags:</label>
                <div class="tags-input-group">
                    <input type="text" id="editNewTag" placeholder="Neuer Tag...">
                    <button class="btn-secondary" id="addEditTagBtn">+ Tag</button>
                </div>
                <div class="tag-list" id="editTags"></div>
            </div>
            <div class="button-group">
                <button class="btn-primary" id="saveEditBtn">Speichern</button>
                <button class="btn-secondary" id="cancelEditBtn">Abbrechen</button>
            </div>
            <div class="error" id="editError" role="alert"></div>
            <div class="success" id="editSuccess" role="status"></div>
        </div>
    </div>

    <!-- Batch Summary Modal -->
    <div class="modal" id="batchSummaryModal" role="dialog" aria-labelledby="batchSummaryTitle">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="section-title" id="batchSummaryTitle">Zusammenfassung mehrerer Notizen</h2>
                <button class="modal-close" id="closeBatchSummaryModal" aria-label="Schlie√üen">‚úï</button>
            </div>
            <div class="loading show" id="batchSummaryLoading" role="status">KI erstellt Gesamt-Zusammenfassung...</div>
            <textarea id="batchSummaryText" style="display:none;" aria-label="Gesamt-Zusammenfassung"></textarea>
            <div class="button-group" id="batchSummaryActions" style="display:none;">
                <button class="btn-primary" id="saveBatchSummaryBtn">Als neue Notiz speichern</button>
                <button class="btn-icon" id="copyBatchSummaryBtn">Kopieren</button>
                <button class="btn-secondary" id="closeBatchSummaryBtn">Schlie√üen</button>
            </div>
            <div class="success" id="batchSummarySuccess" role="status"></div>
        </div>
    </div>
    
    <!-- Confirmation Modal -->
    <div class="modal" id="confirmModal" role="dialog" aria-labelledby="confirmTitle">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="section-title" id="confirmTitle">Best√§tigung</h2>
                <button class="modal-close" id="closeConfirmModal" aria-label="Schlie√üen">‚úï</button>
            </div>
            <p id="confirmMessage" style="margin-bottom: 20px;">Sind Sie sicher?</p>
            <div class="button-group">
                <button class="btn-primary" id="confirmYesBtn">Ja</button>
                <button class="btn-secondary" id="confirmNoBtn">Nein</button>
            </div>
        </div>
    </div>

    <script>
        let recognition;
        let isRecording = false;
        let currentTranscript = '';
        let currentLocation = null;
        let currentTags = [];
        let selectionMode = false;
        let selectedEntries = new Set();
        let editingEntryId = null;
        let activeTagFilter = null;
        let confirmCallback = null;

        const DIARY_KEY = 'diary_entries_v2';

        document.addEventListener('DOMContentLoaded', () => {
            loadAPIKey();
            loadEntries();
            initSpeechRecognition();
            setupEventListeners();
            // Tags beim Start aktualisieren
            updateAvailableTags(); 
            
            // *NEU: Hier Initialisierungs-Funktionen aufrufen*
            initIOSFallback();
            initMediaRecorderFallback();
        });

        function getEntries() {
            const stored = localStorage.getItem(DIARY_KEY);
            let entries = stored ? JSON.parse(stored) : [];
            entries.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            return entries;
        }

        function saveEntries(entries) {
            localStorage.setItem(DIARY_KEY, JSON.stringify(entries));
            loadEntries();
            updateAvailableTags(); 
        }

        function setupEventListeners() {
            document.getElementById('apiKey').addEventListener('change', saveAPIKey);
            document.getElementById('apiProvider').addEventListener('change', saveAPIKey);
            document.getElementById('recordBtn').addEventListener('click', toggleRecording);
            document.getElementById('summarizeBtn').addEventListener('click', summarize);
            document.getElementById('cancelBtn').addEventListener('click', cancelTranscript);
            document.getElementById('saveBtn').addEventListener('click', saveEntry);
            document.getElementById('editCancelBtn').addEventListener('click', cancelEdit);
            document.getElementById('locationPermission').addEventListener('change', handleLocationPermission);
            
            document.getElementById('addTagBtn').addEventListener('click', addCurrentTag);
            document.getElementById('newTag').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addCurrentTag();
            });

            document.getElementById('copyBtn').addEventListener('click', copyToClipboard);
            document.getElementById('shareBtn').addEventListener('click', shareContent);

            document.getElementById('reformulateShorter').addEventListener('click', () => reformulate('k√ºrzer'));
            document.getElementById('reformulateFormal').addEventListener('click', () => reformulate('formeller'));
            document.getElementById('reformulateCasual').addEventListener('click', () => reformulate('lockerer'));

            document.getElementById('toggleSelectionBtn').addEventListener('click', toggleSelectionMode);
            
            document.getElementById('summarizeSelectedBtn').addEventListener('click', summarizeSelected);
            document.getElementById('tagSelectedBtn').addEventListener('click', tagSelected);
            document.getElementById('exportSelectedBtn').addEventListener('click', exportSelected);
            document.getElementById('shareSelectedBtn').addEventListener('click', shareSelected);
            document.getElementById('deleteSelectedBtn').addEventListener('click', deleteSelected);

            document.getElementById('closeEditModal').addEventListener('click', closeEditModal);
            document.getElementById('cancelEditBtn').addEventListener('click', closeEditModal);
            document.getElementById('saveEditBtn').addEventListener('click', saveEditedEntry);
            document.getElementById('addEditTagBtn').addEventListener('click', addEditTag);
            document.getElementById('editNewTag').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addEditTag();
            });

            document.getElementById('closeBatchSummaryModal').addEventListener('click', closeBatchSummaryModal);
            document.getElementById('closeBatchSummaryBtn').addEventListener('click', closeBatchSummaryModal);
            document.getElementById('saveBatchSummaryBtn').addEventListener('click', saveBatchSummary);
            document.getElementById('copyBatchSummaryBtn').addEventListener('click', copyBatchSummary);
            
            document.getElementById('confirmYesBtn').addEventListener('click', () => {
                if (confirmCallback) {
                    const cb = confirmCallback;
                    closeConfirmModal();
                    cb();
                } else {
                    closeConfirmModal();
                }
            });
            document.getElementById('confirmNoBtn').addEventListener('click', closeConfirmModal);
            document.getElementById('closeConfirmModal').addEventListener('click', closeConfirmModal);
        }

        function initSpeechRecognition() {
            const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!SR) {
                document.getElementById('recordBtn').disabled = true;
                // showError('Spracherkennung wird in diesem Browser nicht unterst√ºtzt.'); // Nur √ºber Diagnose anzeigen
                return;
            }

            recognition = new SR();
            recognition.continuous = true;
            recognition.interimResults = true;
            recognition.lang = 'de-DE';

            recognition.onresult = (event) => {
                let interim = '';
                let final = '';
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    if (event.results[i].isFinal) {
                        final += event.results[i][0].transcript + ' ';
                    } else {
                        interim += event.results[i][0].transcript;
                    }
                }
                currentTranscript += final;
                document.getElementById('transcript').value = currentTranscript.trim() + ' ' + interim.trim();
                document.getElementById('transcriptSection').classList.add('show');
            };

            recognition.onerror = (event) => {
                console.error('Speech recognition error:', event.error);
                // showError('Fehler bei der Spracherkennung: ' + event.error); // Diagnose hookt ein
                stopRecording();
            };
        }

        function toggleRecording() {
            if (isRecording) {
                stopRecording();
            } else {
                startRecording();
            }
        }

        // startRecording und stopRecording wurden durch das Override-Skript ersetzt

        function getCurrentLocation() {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        currentLocation = {
                            latitude: position.coords.latitude,
                            longitude: position.coords.longitude
                        };
                    },
                    (error) => {
                        console.error('Location error:', error);
                        currentLocation = null;
                    }
                );
            }
        }

        function handleLocationPermission() {
            if (document.getElementById('locationPermission').checked) {
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(
                        () => console.log('Location permission granted'),
                        (error) => {
                            console.error('Location permission denied:', error);
                            document.getElementById('locationPermission').checked = false;
                            showError('Standort-Berechtigung wurde verweigert');
                        }
                    );
                }
            }
        }

        async function summarize() {
            const transcript = document.getElementById('transcript').value.trim();
            if (!transcript) { showError('Keine Transkription vorhanden.'); return; }

            const apiKey = document.getElementById('apiKey').value.trim();
            const provider = document.getElementById('apiProvider').value;
            
            if (!apiKey) { showError('Bitte gib einen API-Schl√ºssel ein.'); return; }

            document.getElementById('loading').classList.add('show');
            document.getElementById('error').classList.remove('show');

            try {
                let summary = await callLLMAPI(transcript, apiKey, provider);
                document.getElementById('summary').value = summary;
                document.getElementById('summarySection').classList.add('show');
                document.getElementById('loading').classList.remove('show');
                currentTags = [];
                updateCurrentTags();
            } catch (error) {
                showError('Fehler beim Erstellen der Zusammenfassung: ' + error.message);
                document.getElementById('loading').classList.remove('show');
            }
        }

        async function reformulate(style) {
            const summary = document.getElementById('summary').value.trim();
            if (!summary) { showError('Keine Zusammenfassung vorhanden.'); return; }

            const apiKey = document.getElementById('apiKey').value.trim();
            const provider = document.getElementById('apiProvider').value;
            
            if (!apiKey) { showError('Bitte gib einen API-Schl√ºssel ein.'); return; }

            document.getElementById('reformulateLoading').classList.add('show');
            document.getElementById('success').classList.remove('show');

            try {
                let prompt = '';
                if (style === 'k√ºrzer') {
                    prompt = `Formuliere den folgenden Text deutlich k√ºrzer (max. 50% der Originall√§nge), aber behalte alle wichtigen Informationen:\n\n${summary}`;
                } else if (style === 'formeller') {
                    prompt = `Formuliere den folgenden Text formeller und professioneller:\n\n${summary}`;
                } else if (style === 'lockerer') {
                    prompt = `Formuliere den folgenden Text lockerer und umgangssprachlicher:\n\n${summary}`;
                }

                let reformulated = await callLLMAPI(prompt, apiKey, provider);
                document.getElementById('summary').value = reformulated;
                document.getElementById('reformulateLoading').classList.remove('show');
                showSuccess('Erfolgreich neu formuliert!');
            } catch (error) {
                showError('Fehler beim Neu-Formulieren: ' + error.message);
                document.getElementById('reformulateLoading').classList.remove('show');
            }
        }

        function addCurrentTag() {
            const tagInput = document.getElementById('newTag');
            const tag = tagInput.value.trim();
            if (tag && !currentTags.includes(tag)) {
                currentTags.push(tag);
                updateCurrentTags();
                tagInput.value = '';
            }
        }

        function updateCurrentTags() {
            const container = document.getElementById('currentTags');
            container.innerHTML = '';
            currentTags.forEach(tag => {
                const wrap = document.createElement('div');
                wrap.className = 'tag';
                const txt = document.createElement('span');
                txt.textContent = tag;
                const btn = document.createElement('button');
                btn.className = 'tag-remove';
                btn.textContent = '√ó';
                btn.setAttribute('aria-label', `Tag ${tag} entfernen`);
                btn.addEventListener('click', () => removeCurrentTag(tag));
                wrap.appendChild(txt);
                wrap.appendChild(btn);
                container.appendChild(wrap);
            });
            updateAvailableTags();
        }

        function removeCurrentTag(tag) {
            currentTags = currentTags.filter(t => t !== tag);
            updateCurrentTags();
        }
        
        // NEUE FUNKTION: Tags sammeln und anzeigen
        function updateAvailableTags() {
            const allEntries = getEntries();
            const allTags = new Set();
            allEntries.forEach(entry => {
                if (entry.tags) entry.tags.forEach(tag => allTags.add(tag));
            });

            // Tags f√ºr den Haupt-Tag-Bereich (Neue Notiz)
            const container = document.getElementById('availableTags');
            renderTagSuggestions(container, allTags, tag => {
                if (!currentTags.includes(tag)) {
                    currentTags.push(tag);
                } else {
                    currentTags = currentTags.filter(t => t !== tag);
                }
                updateCurrentTags();
            }, currentTags);
            
            // Tags f√ºr den Edit-Modal-Bereich
            const editContainer = document.getElementById('editAvailableTags');
            // Stelle sicher, dass `currentTags` im Edit Modal die Tags des Eintrags reflektieren, wenn es offen ist
            const tagsForEditModal = editingEntryId ? getEntries().find(e => e.id === editingEntryId)?.tags || [] : currentTags;
            renderTagSuggestions(editContainer, allTags, tag => {
                if (!currentTags.includes(tag)) {
                    currentTags.push(tag);
                } else {
                    currentTags = currentTags.filter(t => t !== tag);
                }
                updateEditTags();
            }, tagsForEditModal);

            // Tags f√ºr den Filter-Bereich
            updateTagFilter(allEntries);
        }

        // Hilfsfunktion zum Rendern der klickbaren Tag-Vorschl√§ge
        function renderTagSuggestions(container, tags, clickHandler, activeTags) {
            container.innerHTML = '';
            Array.from(tags).sort().forEach(tag => {
                const tagEl = document.createElement('div');
                tagEl.className = `tag-suggestion ${activeTags.includes(tag) ? 'active' : ''}`;
                tagEl.textContent = tag;
                tagEl.addEventListener('click', () => clickHandler(tag));
                container.appendChild(tagEl);
            });
        }


        function addEditTag() {
            const tagInput = document.getElementById('editNewTag');
            const tag = tagInput.value.trim();
            if (tag && !currentTags.includes(tag)) {
                currentTags.push(tag);
                updateEditTags();
                tagInput.value = '';
            }
        }

        function updateEditTags() {
            const container = document.getElementById('editTags');
            container.innerHTML = '';
            currentTags.forEach(tag => {
                const wrap = document.createElement('div');
                wrap.className = 'tag';
                const txt = document.createElement('span');
                txt.textContent = tag;
                const btn = document.createElement('button');
                btn.className = 'tag-remove';
                btn.textContent = '√ó';
                btn.setAttribute('aria-label', `Tag ${tag} entfernen`);
                btn.addEventListener('click', () => removeEditTag(tag));
                wrap.appendChild(txt);
                wrap.appendChild(btn);
                container.appendChild(wrap);
            });
            updateAvailableTags(); // Tags im Modal nach dem Editieren aktualisieren
        }

        function removeEditTag(tag) {
            currentTags = currentTags.filter(t => t !== tag);
            updateEditTags();
        }

        function saveEntry() {
            const summary = document.getElementById('summary').value.trim();
            if (!summary) { showError('Keine Zusammenfassung vorhanden.'); return; }

            const entry = {
                id: Date.now().toString(),
                text: summary,
                timestamp: new Date().toISOString(),
                location: currentLocation || null,
                tags: [...currentTags],
                transcript: currentTranscript || ''
            };

            const entries = getEntries();
            entries.unshift(entry);
            saveEntries(entries);

            showSuccess('Notiz gespeichert!');
            setTimeout(() => { resetForm(); }, 1000);
        }

        function deleteEntry(id) {
            showConfirmModal('Eintrag wirklich l√∂schen?', () => {
                const entries = getEntries().filter(e => e.id !== id);
                saveEntries(entries);
                showSuccess('Eintrag gel√∂scht!');
            });
        }

        function editEntry(id) {
            const entry = getEntries().find(e => e.id === id);
            if (!entry) return;

            editingEntryId = id;
            document.getElementById('editText').value = entry.text;
            document.getElementById('editModal').classList.add('show');
            document.getElementById('editError').classList.remove('show');
            document.getElementById('editSuccess').classList.remove('show');
            
            currentTags = entry.tags ? [...entry.tags] : [];
            updateEditTags();
            updateAvailableTags(); // Wichtig, um die Tags im Modal neu zu rendern
        }

        function saveEditedEntry() {
            const text = document.getElementById('editText').value.trim();
            if (!text) { showError('Text darf nicht leer sein.', 'editError'); return; }

            const entries = getEntries();
            const entryIndex = entries.findIndex(e => e.id === editingEntryId);

            if (entryIndex > -1) {
                entries[entryIndex].text = text;
                entries[entryIndex].tags = [...currentTags];
                saveEntries(entries);
                
                showSuccess('Eintrag aktualisiert!', 'editSuccess');
                setTimeout(() => closeEditModal(), 1000);
            }
        }

        function closeEditModal() {
            document.getElementById('editModal').classList.remove('show');
            editingEntryId = null;
            currentTags = [];
        }

        async function reformulateEntry(id) {
            const entry = getEntries().find(e => e.id === id);
            if (!entry) return;

            const style = prompt('Wie soll neu formuliert werden? (k√ºrzer/formeller/lockerer)');
            if (!style || !['k√ºrzer', 'formeller', 'lockerer'].includes(style.toLowerCase())) return;

            const apiKey = document.getElementById('apiKey').value.trim();
            const provider = document.getElementById('apiProvider').value;
            
            if (!apiKey) { showError('Bitte gib einen API-Schl√ºssel ein.'); return; }

            showSuccess('Formuliere um...');

            try {
                let prompt = '';
                if (style.toLowerCase() === 'k√ºrzer') {
                    prompt = `Formuliere den folgenden Text deutlich k√ºrzer (max. 50% der Originall√§nge), aber behalte alle wichtigen Informationen:\n\n${entry.text}`;
                } else if (style.toLowerCase() === 'formeller') {
                    prompt = `Formuliere den folgenden Text formeller und professioneller:\n\n${entry.text}`;
                } else if (style.toLowerCase() === 'lockerer') {
                    prompt = `Formuliere den folgenden Text lockerer und umgangssprachlicher:\n\n${entry.text}`;
                }

                let reformulated = await callLLMAPI(prompt, apiKey, provider);

                const entries = getEntries();
                const entryIndex = entries.findIndex(e => e.id === id);
                if (entryIndex > -1) {
                    entries[entryIndex].text = reformulated;
                    saveEntries(entries);
                    showSuccess('Erfolgreich neu formuliert!');
                }
            } catch (error) {
                showError('Fehler beim Neu-Formulieren: ' + error.message);
            }
        }

        async function copyEntry(id) {
            const entry = getEntries().find(e => e.id === id);
            if (!entry) return;

            try {
                await navigator.clipboard.writeText(entry.text);
                showSuccess('In Zwischenablage kopiert!');
            } catch (error) {
                showError('Fehler beim Kopieren: ' + error.message);
            }
        }

        async function shareEntry(id) {
            const entry = getEntries().find(e => e.id === id);
            if (!entry) return;

            if (navigator.share) {
                try {
                    await navigator.share({ title: 'Sprach-Tagebuch Notiz', text: entry.text });
                } catch (error) {
                    console.log('Sharing cancelled');
                }
            } else {
                showError('Teilen wird in diesem Browser nicht unterst√ºtzt.');
            }
        }

        function loadEntries() {
            let entries = getEntries();
            
            if (activeTagFilter) {
                entries = entries.filter(e => e.tags && e.tags.includes(activeTagFilter));
            }

            renderEntries(entries);
            // updateTagFilter wird in updateAvailableTags aufgerufen.
        }

        function renderEntries(entries) {
            const container = document.getElementById('entries');
            container.innerHTML = '';
            
            if (entries.length === 0) {
                const empty = document.createElement('div');
                empty.className = 'empty-state';
                empty.textContent = 'Noch keine Eintr√§ge vorhanden.\nNimm deine erste Notiz auf!';
                container.appendChild(empty);
                return;
            }

            entries.forEach(entry => {
                const entryDiv = document.createElement('div');
                entryDiv.className = `entry ${selectionMode ? 'selection-mode' : ''}`;

                if (selectionMode) {
                    const cb = document.createElement('input');
                    cb.type = 'checkbox';
                    cb.className = 'entry-checkbox';
                    cb.checked = selectedEntries.has(entry.id);
                    cb.setAttribute('aria-label', `Notiz vom ${new Date(entry.timestamp).toLocaleDateString('de-DE')} ausw√§hlen`);
                    cb.addEventListener('change', e => {
                        if (e.target.checked) selectedEntries.add(entry.id);
                        else selectedEntries.delete(entry.id);
                        updateBatchActionsVisibility();
                    });
                    entryDiv.appendChild(cb);
                }

                const header = document.createElement('div');
                header.className = 'entry-header';
                const dateDiv = document.createElement('div');
                const dateEl = document.createElement('div');
                dateEl.className = 'entry-date';
                dateEl.textContent = new Date(entry.timestamp).toLocaleDateString('de-DE', {
                    day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit'
                });
                dateDiv.appendChild(dateEl);

                if (entry.location) {
                    const locEl = document.createElement('div');
                    locEl.className = 'entry-location';
                    locEl.textContent = `üìç ${entry.location.latitude.toFixed(4)}, ${entry.location.longitude.toFixed(4)}`;
                    dateDiv.appendChild(locEl);
                }
                header.appendChild(dateDiv);
                entryDiv.appendChild(header);

                if (entry.tags && entry.tags.length > 0) {
                    const tagsDiv = document.createElement('div');
                    tagsDiv.className = 'entry-tags';
                    entry.tags.forEach(tag => {
                        const tagEl = document.createElement('div');
                        tagEl.className = 'tag';
                        tagEl.textContent = tag;
                        tagsDiv.appendChild(tagEl);
                    });
                    entryDiv.appendChild(tagsDiv);
                }

                const textEl = document.createElement('div');
                textEl.className = 'entry-text';
                textEl.textContent = entry.text;
                entryDiv.appendChild(textEl);

                const actions = document.createElement('div');
                actions.className = 'entry-actions';
                
                const btnConfigs = [
                    ['Bearbeiten', 'btn-icon', () => editEntry(entry.id)],
                    ['Neu formulieren', 'btn-icon', () => reformulateEntry(entry.id)],
                    ['Kopieren', 'btn-icon', () => copyEntry(entry.id)],
                    ['Teilen', 'btn-icon', () => shareEntry(entry.id)],
                    ['L√∂schen', 'delete-btn', () => deleteEntry(entry.id)]
                ];

                btnConfigs.forEach(([label, className, handler]) => {
                    const btn = document.createElement('button');
                    btn.className = className;
                    btn.textContent = label;
                    btn.addEventListener('click', handler);
                    actions.appendChild(btn);
                });

                entryDiv.appendChild(actions);
                container.appendChild(entryDiv);
            });
        }

        function updateTagFilter(allEntries) {
            const allTags = new Set();
            allEntries.forEach(entry => {
                if (entry.tags) entry.tags.forEach(tag => allTags.add(tag));
            });

            const container = document.getElementById('tagFilter');
            container.innerHTML = '';
            
            if (allTags.size === 0 && !activeTagFilter) return;

            const allBtn = document.createElement('div');
            allBtn.className = `filter-tag ${!activeTagFilter ? 'active' : ''}`;
            allBtn.textContent = 'Alle';
            allBtn.addEventListener('click', () => filterByTag(null));
            container.appendChild(allBtn);

            Array.from(allTags).forEach(tag => {
                const tagBtn = document.createElement('div');
                tagBtn.className = `filter-tag ${activeTagFilter === tag ? 'active' : ''}`;
                tagBtn.textContent = tag;
                tagBtn.addEventListener('click', () => filterByTag(tag));
                container.appendChild(tagBtn);
            });
        }

        function filterByTag(tag) {
            activeTagFilter = tag;
            loadEntries();
        }

        function toggleSelectionMode() {
            selectionMode = !selectionMode;
            selectedEntries.clear();
            
            const btn = document.getElementById('toggleSelectionBtn');
            btn.textContent = selectionMode ? 'Fertig' : 'Ausw√§hlen';
            
            loadEntries();
            updateBatchActionsVisibility();
        }

        function updateBatchActionsVisibility() {
            const batchActions = document.getElementById('batchActions');
            if (selectionMode && selectedEntries.size > 0) {
                batchActions.classList.add('show');
            } else {
                batchActions.classList.remove('show');
            }
        }

        async function summarizeSelected() {
            const allEntries = getEntries();
            const entries = allEntries.filter(e => selectedEntries.has(e.id));
            if (entries.length === 0) return;

            const apiKey = document.getElementById('apiKey').value.trim();
            const provider = document.getElementById('apiProvider').value;
            
            if (!apiKey) { showError('Bitte gib einen API-Schl√ºssel ein.'); return; }

            document.getElementById('batchSummaryModal').classList.add('show');
            document.getElementById('batchSummaryText').style.display = 'none';
            document.getElementById('batchSummaryActions').style.display = 'none';
            document.getElementById('batchSummaryLoading').classList.add('show');
            document.getElementById('batchSummarySuccess').classList.remove('show');

            try {
                const combinedText = entries.map((e, i) => `Notiz ${i + 1} (${new Date(e.timestamp).toLocaleDateString('de-DE')}):\n${e.text}`).join('\n\n---\n\n');
                
                const prompt = `Erstelle eine pr√§gnante Gesamt-Zusammenfassung der folgenden ${entries.length} Notizen. Identifiziere gemeinsame Themen und wichtige Erkenntnisse:\n\n${combinedText}`;

                let summary = await callLLMAPI(prompt, apiKey, provider);

                document.getElementById('batchSummaryLoading').classList.remove('show');
                document.getElementById('batchSummaryText').value = summary;
                document.getElementById('batchSummaryText').style.display = 'block';
                document.getElementById('batchSummaryActions').style.display = 'flex';
            } catch (error) {
                document.getElementById('batchSummaryLoading').classList.remove('show');
                showError('Fehler beim Zusammenfassen: ' + error.message, 'batchSummarySuccess');
            }
        }

        function saveBatchSummary() {
            const summary = document.getElementById('batchSummaryText').value.trim();
            if (!summary) return;

            const entry = {
                id: Date.now().toString(),
                text: summary,
                timestamp: new Date().toISOString(),
                location: null,
                tags: ['Zusammenfassung'],
                transcript: `Zusammenfassung von ${selectedEntries.size} Notizen`
            };

            const entries = getEntries();
            entries.unshift(entry);
            saveEntries(entries);

            showSuccess('Zusammenfassung gespeichert!', 'batchSummarySuccess');
            setTimeout(() => closeBatchSummaryModal(), 1000);
        }

        function closeBatchSummaryModal() {
            document.getElementById('batchSummaryModal').classList.remove('show');
            document.getElementById('batchSummaryText').value = '';
            document.getElementById('batchSummaryText').style.display = 'none';
            document.getElementById('batchSummaryActions').style.display = 'none';
            document.getElementById('batchSummaryLoading').classList.add('show');
        }

        function copyBatchSummary() {
            const text = document.getElementById('batchSummaryText').value;
            if (!text) return;
            navigator.clipboard.writeText(text).then(() => {
                showSuccess('In Zwischenablage kopiert!', 'batchSummarySuccess');
            }).catch(() => {
                showError('Fehler beim Kopieren.', 'batchSummarySuccess');
            });
        }

        function deleteSelected() {
            if (selectedEntries.size === 0) return;

            showConfirmModal(`${selectedEntries.size} Eintr√§ge wirklich l√∂schen?`, () => {
                const entries = getEntries().filter(e => !selectedEntries.has(e.id));
                saveEntries(entries);
                
                selectedEntries.clear();
                toggleSelectionMode();
                showSuccess('Ausgew√§hlte Eintr√§ge gel√∂scht!');
            });
        }

        function tagSelected() {
            const tag = prompt('Tag f√ºr ausgew√§hlte Eintr√§ge:');
            if (!tag || selectedEntries.size === 0) return;

            const entries = getEntries();
            let changed = false;
            entries.forEach(entry => {
                if (selectedEntries.has(entry.id)) {
                    if (!entry.tags) entry.tags = [];
                    if (!entry.tags.includes(tag)) {
                        entry.tags.push(tag);
                        changed = true;
                    }
                }
            });
            
            if (changed) {
                saveEntries(entries);
                showSuccess('Tags hinzugef√ºgt!');
            }
        }

        function exportSelected() {
            const allEntries = getEntries();
            const entries = allEntries.filter(e => selectedEntries.has(e.id));
            if (entries.length === 0) return;

            const text = entries.map(e => {
                const date = new Date(e.timestamp).toLocaleString('de-DE');
                const tags = e.tags ? `\nTags: ${e.tags.join(', ')}` : '';
                const location = e.location ? `\nStandort: ${e.location.latitude}, ${e.location.longitude}` : '';
                return `=== ${date} ===${tags}${location}\n\n${e.text}`;
            }).join('\n\n' + '='.repeat(50) + '\n\n');

            const blob = new Blob([text], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `notizen_${new Date().toISOString().split('T')[0]}.txt`;
            a.click();
            URL.revokeObjectURL(url);

            showSuccess('Exportiert!');
        }

        async function shareSelected() {
            const allEntries = getEntries();
            const entries = allEntries.filter(e => selectedEntries.has(e.id));
            if (entries.length === 0) return;

            const text = entries.map(e => {
                const date = new Date(e.timestamp).toLocaleDateString('de-DE');
                return `${date}:\n${e.text}`;
            }).join('\n\n---\n\n');

            if (navigator.share) {
                try {
                    await navigator.share({ title: 'Meine Notizen', text: text });
                } catch (error) {
                    console.log('Sharing cancelled');
                }
            } else {
                showError('Teilen wird in diesem Browser nicht unterst√ºtzt.');
            }
        }

        function saveAPIKey() {
            localStorage.setItem('api_key', document.getElementById('apiKey').value);
            localStorage.setItem('api_provider', document.getElementById('apiProvider').value);
        }

        function loadAPIKey() {
            const apiKey = localStorage.getItem('api_key');
            const provider = localStorage.getItem('api_provider');
            if (apiKey) document.getElementById('apiKey').value = apiKey;
            if (provider) document.getElementById('apiProvider').value = provider;
        }

        function showError(message, targetId = 'error') {
            const errorEl = document.getElementById(targetId);
            errorEl.textContent = message;
            errorEl.classList.add('show');
            setTimeout(() => errorEl.classList.remove('show'), 5000);
        }

        function showSuccess(message, targetId = 'success') {
            const successEl = document.getElementById(targetId);
            successEl.textContent = message;
            successEl.classList.add('show');
            setTimeout(() => successEl.classList.remove('show'), 3000);
        }

        function showConfirmModal(message, callback) {
            document.getElementById('confirmMessage').textContent = message;
            document.getElementById('confirmModal').classList.add('show');
            confirmCallback = callback;
        }

        function closeConfirmModal() {
            document.getElementById('confirmModal').classList.remove('show');
            confirmCallback = null;
        }

        async function copyToClipboard() {
            const text = document.getElementById('summary').value;
            try {
                await navigator.clipboard.writeText(text);
                showSuccess('In Zwischenablage kopiert!');
            } catch (error) {
                showError('Fehler beim Kopieren: ' + error.message);
            }
        }

        async function shareContent() {
            const text = document.getElementById('summary').value;
            if (navigator.share) {
                try {
                    await navigator.share({ title: 'Sprach-Tagebuch Notiz', text: text });
                } catch (error) {
                    console.log('Sharing cancelled');
                }
            } else {
                showError('Teilen wird in diesem Browser nicht unterst√ºtzt.');
            }
        }

        function cancelTranscript() { resetForm(); }
        function cancelEdit() { resetForm(); }

        function resetForm() {
            currentTranscript = '';
            currentLocation = null;
            currentTags = [];
            document.getElementById('transcript').value = '';
            document.getElementById('summary').value = '';
            document.getElementById('newTag').value = '';
            document.getElementById('transcriptSection').classList.remove('show');
            document.getElementById('summarySection').classList.remove('show');
            document.getElementById('status').textContent = 'Bereit zur Aufnahme';
            updateCurrentTags();
            document.getElementById('error').classList.remove('show');
            document.getElementById('success').classList.remove('show');
        }

        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                
navigator.serviceWorker.register('./sw.js').then(reg => {
    console.log('Service Worker registriert', reg);
    // Wenn bereits ein wartender Worker existiert: sofort aktivieren
    if (reg.waiting) { reg.waiting.postMessage('SKIP_WAITING'); }
    // Bei Updates
    reg.addEventListener('updatefound', () => {
        const nw = reg.installing;
        if (nw) {
            nw.addEventListener('statechange', () => {
                if (nw.state === 'installed' && reg.waiting) {
                    reg.waiting.postMessage('SKIP_WAITING');
                }
            });
        }
    });
}).catch(err => console.log('SW registration failed:', err));

// Neu laden, wenn der Controller wechselt (App-Update)
navigator.serviceWorker.addEventListener('controllerchange', () => {
    console.log('Neue Version aktiv ‚Äì Seite wird aktualisiert‚Ä¶');
    window.location.reload();
});

            });
        }
    </script>

    <!-- KI API Logik -->
    <script>
        // Funktion zum Extrahieren der KI-Antwort basierend auf dem Anbieter
        function handleAPIResponse(provider, data) {
            if (provider === 'anthropic') {
                // Anthropic (Claude) Antwortstruktur
                const textBlock = data.content?.find(block => block.type === 'text');
                return textBlock?.text || 'Fehler beim Parsen der Anthropic-Antwort.';
            } else if (provider === 'openai') {
                // OpenAI (GPT) Antwortstruktur
                return data.choices?.[0]?.message?.content || 'Fehler beim Parsen der OpenAI-Antwort.';
            } else if (provider === 'gemini') {
                // Google (Gemini) Antwortstruktur
                return data.candidates?.[0]?.content?.parts?.[0]?.text || 'Fehler beim Parsen der Gemini-Antwort.';
            }
            return 'Unbekannter KI-Anbieter.';
        }

        // Hauptfunktion f√ºr den KI-API-Aufruf
        async function callLLMAPI(userPrompt, apiKey, provider, retryCount = 0) {
            let url = '';
            let headers = {};
            let body = {};
            let model = '';
            let systemInstruction = 'Du bist ein freundlicher, pr√§gnanter Assistent, der Sprachnotizen zusammenfasst und umformuliert. Deine Antwort soll nur die gew√ºnschte Ausgabe enthalten, ohne einleitenden Text wie "Hier ist die Zusammenfassung". Antworte auf Deutsch.';

            // API Konfiguration basierend auf Anbieter
            if (provider === 'anthropic') {
                url = 'https://api.anthropic.com/v1/messages';
                model = 'claude-3-haiku-20240307';
                headers = {
                    'Content-Type': 'application/json',
                    'x-api-key': apiKey,
                    'anthropic-version': '2023-06-01'
                };
                body = {
                    model: model,
                    max_tokens: 2000,
                    system: systemInstruction,
                    messages: [
                        { role: 'user', content: userPrompt }
                    ]
                };
            } else if (provider === 'openai') {
                url = 'https://api.openai.com/v1/chat/completions';
                model = 'gpt-3.5-turbo';
                headers = {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                };
                body = {
                    model: model,
                    messages: [
                        { role: 'system', content: systemInstruction },
                        { role: 'user', content: userPrompt }
                    ],
                    max_tokens: 2000
                };
            } else if (provider === 'gemini') {
                // Gemini verwendet den Canvas-Proxy, daher kein API-Key im Header, sondern in der URL
                url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
                headers = {
                    'Content-Type': 'application/json'
                };
                // Korrigierte Struktur: generationConfig statt config und maxOutputTokens direkt darin
                body = {
                    contents: [{ parts: [{ text: userPrompt }] }],
                    systemInstruction: { parts: [{ text: systemInstruction }] },
                    generationConfig: { maxOutputTokens: 2000 }
                };
            } else {
                throw new Error('Unbekannter KI-Anbieter ausgew√§hlt.');
            }

            try {
                const response = await fetch(url, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(body)
                });

                const data = await response.json();

                if (!response.ok) {
                    const errorMsg = data.error?.message || data.error?.type || 'Unbekannter Fehler';
                    throw new Error(`API-Fehler (${response.status}): ${errorMsg}`);
                }

                // Fehlerbehandlung f√ºr unvollst√§ndige Antworten
                const resultText = handleAPIResponse(provider, data);
                if (resultText.startsWith('Fehler beim Parsen')) {
                     throw new Error(resultText);
                }
                
                return resultText;

            } catch (error) {
                // Exponential Backoff f√ºr Netzwerkfehler oder Timeout
                if (retryCount < 3 && (error.message.includes('Failed to fetch') || error.message.includes('Timeout'))) {
                    const delay = Math.pow(2, retryCount) * 1000;
                    console.warn(`API-Aufruf fehlgeschlagen. Versuche es in ${delay}ms erneut...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    return callLLMAPI(userPrompt, apiKey, provider, retryCount + 1);
                }
                throw error;
            }
        }
    </script>
    
<section class="diag-card" id="diagnostics">
  <h3 style="margin-top:0">Diagnose</h3>
  <div class="diag-grid">
    <div>Zustand</div>
    <div><span id="diag-state" class="state-badge state-warn">bereit</span></div>

    <div>Mikrofon-Pegel</div>
    <div class="level-wrap"><div id="diag-level" class="level-bar anim"></div></div>

    <div>Letzter Fehler</div>
    <div id="diag-last-error">‚Äì</div>

    <div>Ereignis-Log</div>
    <div id="diag-log" aria-live="polite"></div>
<div style="grid-column:1 / span 2; display:flex; gap:8px; margin-top:8px;"><button id="diagStart" type="button">Diagnose starten</button><button id="diagStop" type="button">Diagnose stoppen</button></div>
  </div>
</section>


<script id="diag-script">
  (function(){
    const $state = () => document.getElementById('diag-state');
    const $log = () => document.getElementById('diag-log');
    const $err = () => document.getElementById('diag-last-error');
    const $lvl = () => document.getElementById('diag-level');

    window.__memotag = window.__memotag || {};
    let audioCtx, analyser, micStream, rafId;
    let lowLevelStart = null;

    function ts(){
      const d = new Date();
      return d.toLocaleTimeString();
    }

    window.diagSetState = function(text, cls){
      const el = $state();
      if(!el) return;
      el.textContent = text;
      el.classList.remove('state-ok','state-warn','state-err');
      el.classList.add(cls || 'state-warn');
    }

    window.diagLog = function(msg){
      const el = $log();
      if(!el) return;
      const line = document.createElement('div');
      line.className = 'line';
      line.textContent = `[${ts()}] ${msg}`;
      el.prepend(line);
      const nodes = el.querySelectorAll('.line');
      if(nodes.length > 60) el.removeChild(nodes[nodes.length-1]);
    }

    window.diagError = function(msg){
      const el = $err();
      if(el) el.textContent = msg || '‚Äì';
      diagSetState('Fehler', 'state-err');
      diagLog('ERROR: ' + msg);
    }

    window.startMicMeter = async function(){
      try{
        if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){
          diagLog('getUserMedia nicht verf√ºgbar');
          return;
        }
        micStream = await navigator.mediaDevices.getUserMedia({audio:true});
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 2048;
        const source = audioCtx.createMediaStreamSource(micStream);
        source.connect(analyser);
        const data = new Uint8Array(analyser.fftSize);

        function tick(){
          analyser.getByteTimeDomainData(data);
          let sum = 0;
          for(let i=0;i<data.length;i++){ const v = (data[i]-128)/128; sum += v*v; }
          const rms = Math.sqrt(sum/data.length);
          const pct = Math.min(100, Math.max(0, Math.round(rms*180)));
          const bar = $lvl();
          if(bar){ bar.style.width = pct + '%'; }
          if(pct < 5){
            if(!lowLevelStart) lowLevelStart = performance.now();
            else if(performance.now() - lowLevelStart > 3000){
              diagLog('Hinweis: Sehr niedriger Pegel erkannt (Mikro weit weg? stumm?)');
              lowLevelStart = null;
            }
          } else {
            lowLevelStart = null;
          }
          rafId = requestAnimationFrame(tick);
        }
        tick();
        diagLog('Mic-Meter gestartet');
      }catch(e){
        diagError('Mic-Meter Fehler: ' + e.message);
      }
    }

    window.stopMicMeter = function(){
      if(rafId) cancelAnimationFrame(rafId);
      rafId = null;
      try { if(micStream){ micStream.getTracks().forEach(t=>t.stop()); } } catch(e){}
      try { if(audioCtx){ audioCtx.close(); } } catch(e){}
      const bar = $lvl();
      if(bar){ bar.style.width = '0%'; }
      diagLog('Mic-Meter gestoppt');
    }

    const _origInit = window.initSpeechRecognition;
    window.initSpeechRecognition = function(){
      if(typeof _origInit === 'function'){
        _origInit();
      }
      try{
        if(window.recognition){
          const r = window.recognition;
          r.onstart = ()=>{ diagSetState('l√§uft', 'state-ok'); diagLog('onstart'); };
          r.onaudiostart = ()=>{ diagLog('onaudiostart'); };
          r.onsoundstart = ()=>{ diagLog('onsoundstart'); };
          r.onspeechstart = ()=>{ diagSetState('Sprache erkannt', 'state-ok'); diagLog('onspeechstart'); };
          r.onspeechend = ()=>{ diagLog('onspeechend'); };
          r.onsoundend = ()=>{ diagLog('onsoundend'); };
          r.onaudioend = ()=>{ diagLog('onaudioend'); };
          const prevOnResult = r.onresult;
          r.onresult = (ev)=>{ diagLog('onresult (' + ev.results.length + ' Segmente)'); if(prevOnResult) prevOnResult(ev); };
          r.onerror = (ev)=>{ diagError(ev.error || 'Unbekannter Fehler'); try{ if(window.stopRecording) window.stopRecording(); }catch(e){} };
          r.onend = ()=>{
            diagLog('onend');
            if(window.isRecording){
              diagSetState('automatischer Neustart...', 'state-warn');
              try { r.start(); } catch(e) { diagLog('Restart Fehler: ' + e.message); }
            } else {
              diagSetState('beendet', 'state-warn');
            }
          };
        }
      }catch(e){
        diagError('Init-Hook Fehler: ' + e.message);
      }
    }

    window.__memotag.diag = { diagSetState, diagLog, diagError, startMicMeter, stopMicMeter };
  })();
</script>


<script id="override-start-stop">
// --- Override start/stop to wire diagnostics and robust restart ---
function startRecording() {
  // Reset transcript UI
  currentTranscript = '';
  const t = document.getElementById('transcript');
  if (t) t.value = '';
  const ts = document.getElementById('transcriptSection');
  const ss = document.getElementById('summarySection');
  if (ts) ts.classList.add('show');
  if (ss) ss.classList.remove('show');

  // Diagnostics
  try {
    if (window.__memotag && window.__memotag.diag) {
      __memotag.diag.diagSetState('startet‚Ä¶', 'state-warn');
      __memotag.diag.startMicMeter();
      __memotag.diag.diagLog('Start-Button');
    }
  } catch(_) {}

  // Robust: abort any previous and re-init fresh
  try { if (recognition && recognition.abort) recognition.abort(); } catch(e){}
  try { initSpeechRecognition(); } catch(e){}

  setTimeout(() => {
    try { recognition.start(); } catch (e) {
      try { diagError && diagError('Recognition Start Error: ' + e.message); } catch(_) {}
      showError('Aufnahme konnte nicht gestartet werden. Pr√ºfe die Mikrofon-Berechtigung.');
      return;
    }
    isRecording = true;
    const btn = document.getElementById('recordBtn');
    if (btn) {
      btn.classList.add('recording');
      btn.textContent = '‚èπÔ∏è';
      btn.setAttribute('aria-label', 'Aufnahme stoppen');
    }
    const status = document.getElementById('status');
    if (status) status.textContent = 'Aufnahme l√§uft...';

    if (document.getElementById('locationPermission')?.checked) {
      getCurrentLocation && getCurrentLocation();
    }

    // Safety timeout
    clearTimeout(window.__recTimeout);
    window.__recTimeout = setTimeout(() => { try { stopRecording(); } catch(e){} }, 90 * 1000);
  }, 60);
}

function stopRecording() {
  clearTimeout(window.__recTimeout);
  try { recognition && recognition.stop && recognition.stop(); } catch(e){}
  try { recognition && recognition.abort && recognition.abort(); } catch(e){}
  isRecording = false;

  // Diagnostics
  try {
    if (window.__memotag && window.__memotag.diag) {
      __memotag.diag.diagLog('Stop-Button');
      __memotag.diag.stopMicMeter();
      __memotag.diag.diagSetState('beendet', 'state-warn');
    }
  } catch(_) {}

  const btn = document.getElementById('recordBtn');
  if (btn) {
    btn.classList.remove('recording');
    btn.textContent = 'üé§';
    btn.setAttribute('aria-label', 'Aufnahme starten');
  }
  const status = document.getElementById('status');
  if (status) status.textContent = 'Aufnahme beendet';

  const txt = (currentTranscript || '').trim();
  if (txt) {
    const ts = document.getElementById('transcriptSection');
    if (ts) ts.classList.add('show');
    const t = document.getElementById('transcript');
    if (t) t.value = txt;
  } else {
    const ts = document.getElementById('transcriptSection');
    if (ts) ts.classList.remove('show');
  }
}
</script>

<script>

document.addEventListener('DOMContentLoaded', () => {
    const hash = location.hash;
    if (hash === '#new') {
        const b = document.getElementById('recordBtn');
        if (b) { b.scrollIntoView({behavior:'smooth', block:'center'}); b.focus(); }
    } else if (hash === '#entries') {
        const e = document.querySelector('.entries-section');
        if (e) e.scrollIntoView({behavior:'smooth', block:'start'});
    }
});

</script>
<script>

// ---- iOS Fallback: Audioaufnahme/-Upload + Transkription ----
function isIOS() {
    return /iPhone|iPad|iPod/i.test(navigator.userAgent);
}

function initIOSFallback() {
    // Diagnose-Log hinzuf√ºgen, um zu sehen, ob die Funktion aufgerufen wird
    try { if(window.__memotag?.diag) __memotag.diag.diagLog('Init: iOS Fallback (Audio Upload)'); } catch(_) {}

    const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
    const onIOS = isIOS();
    const hasSR = !!SR;
    const iosHint = document.getElementById('iosHint');
    if (onIOS) {
        if (iosHint) iosHint.style.display = 'block';
    }
    if (!hasSR || onIOS) {
        const btn = document.getElementById('recordBtn');
        if (btn) {
            btn.disabled = true;
            btn.title = onIOS ? 'Live-Spracherkennung wird auf iOS nicht unterst√ºtzt' : 'Spracherkennung in diesem Browser nicht verf√ºgbar';
        }
    }
    const audioBtn = document.getElementById('audioBtn');
    const audioInput = document.getElementById('audioInput');
    if (audioBtn && audioInput) {
        audioBtn.addEventListener('click', () => {
             // Diagnose-Log hinzuf√ºgen
             try { if(window.__memotag?.diag) __memotag.diag.diagLog('Klick: Audio aufnehmen/ausw√§hlen'); } catch(_) {}
             audioInput.click();
        });
        audioInput.addEventListener('change', async (e) => {
            const file = e.target.files && e.target.files[0];
            if (!file) return;
            // Diagnose-Log hinzuf√ºgen
            try { if(window.__memotag?.diag) __memotag.diag.diagLog('Audio-Datei ausgew√§hlt (' + file.name + ')'); } catch(_) {}

            try {
                document.getElementById('status').textContent = 'Audio wird transkribiert...';
                const apiKey = document.getElementById('apiKey').value.trim();
                const provider = document.getElementById('apiProvider').value;
                if (!apiKey) { showError('Bitte gib einen API-Schl√ºssel ein.'); return; }
                const text = await transcribeAudio(file, apiKey, provider);
                currentTranscript = text || '';
                const t = document.getElementById('transcript');
                if (t) t.value = currentTranscript;
                const ts = document.getElementById('transcriptSection');
                if (ts) ts.classList.add('show');
                document.getElementById('status').textContent = 'Transkription abgeschlossen';
            } catch (err) {
                showError('Transkription fehlgeschlagen: ' + (err.message || err));
                document.getElementById('status').textContent = 'Bereit zur Aufnahme';
            } finally {
                // reset input so same file can be reselected
                audioInput.value = '';
            }
        });
    }
}


async function fileToBase64(file) {
    const buf = await file.arrayBuffer();
    let binary = '';
    const bytes = new Uint8Array(buf);
    const chunkSize = 0x8000;
    for (let i = 0; i < bytes.length; i += chunkSize) {
        const chunk = bytes.subarray(i, i + chunkSize);
        // String.fromCharCode.apply(null, chunk) ist langsam und kann zu Stack Overflow f√ºhren.
        // Besser: TextDecoder verwenden
        binary += String.fromCharCode.apply(null, chunk);
    }
    return btoa(binary);
}


function normalizeMime(file) {
    const t = (file.type || '').toLowerCase();
    if (t) return t;
    const name = (file.name || '').toLowerCase();
    if (name.endsWith('.m4a')) return 'audio/mp4';
    if (name.endsWith('.mp3')) return 'audio/mpeg';
    if (name.endsWith('.wav')) return 'audio/wav';
    if (name.endsWith('.ogg')) return 'audio/ogg';
    if (name.endsWith('.webm')) return 'audio/webm';
    return 'application/octet-stream';
}


async function transcribeAudio(file, apiKey, provider) {
    // Size guard (most APIs support at least ~20-25MB; keep it conservative)
    const maxMB = 20;
    if (file.size > maxMB * 1024 * 1024) {
        throw new Error(`Audiodatei ist gr√∂√üer als ${maxMB} MB.`);
    }

    if (provider === 'openai') {
        const url = 'https://api.openai.com/v1/audio/transcriptions';
        const form = new FormData();
        form.append('file', file, file.name || 'audio.m4a');
        form.append('model', 'whisper-1');
        form.append('language', 'de');
        const resp = await fetch(url, {
            method: 'POST',
            headers: { 'Authorization': `Bearer ${apiKey}` },
            body: form
        });
        const data = await resp.json();
        if (!resp.ok) {
            const msg = data.error?.message || 'Unbekannter Fehler';
            throw new Error(`OpenAI-Fehler (${resp.status}): ${msg}`);
        }
        return data.text || '';
    }

    if (provider === 'anthropic') {
        // Claude Messages API mit input_audio Block
        const url = 'https://api.anthropic.com/v1/messages';
        const b64 = await fileToBase64(file);
        const mime = normalizeMime(file);
        const body = {
            model: 'claude-3-5-haiku-latest',
            max_tokens: 2000,
            system: 'Du bist ein pr√§ziser Transkriptionsassistent. Transkribiere nur den gesprochenen deutschen Text, ohne Zusatz.',
            messages: [{
                role: 'user',
                content: [
                    { type: 'text', text: 'Transkribiere dieses Audio auf Deutsch.' },
                    { type: 'input_audio', audio: { type: 'base64', data: b64, media_type: mime } }
                ]
            }]
        };
        const resp = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'x-api-key': apiKey,
                'anthropic-version': '2023-06-01'
            },
            body: JSON.stringify(body)
        });
        const data = await resp.json();
        if (!resp.ok) {
            const msg = data.error?.message || data.error?.type || 'Unbekannter Fehler';
            throw new Error(`Anthropic-Fehler (${resp.status}): ${msg}`);
        }
        // Response: content is an array of blocks; find text
        const block = (data.content || []).find(b => b.type === 'text');
        return (block && block.text) || '';
    }

    if (provider === 'gemini') {
        // Gemini: generateContent mit inlineData
        const mime = normalizeMime(file);
        const b64 = await fileToBase64(file);
        // Modell auf ein unterst√ºtztes Multimodal-Modell aktualisiert (gemini-2.5-flash)
        const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`;
        const body = {
            contents: [{
                parts: [
                    { text: 'Transkribiere dieses Audio auf Deutsch. Antworte nur mit dem reinen Transkript.' },
                    { inlineData: { mimeType: mime, data: b64 } }
                ]
            }],
            generationConfig: { maxOutputTokens: 2000 }
        };
        const resp = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body)
        });
        const data = await resp.json();
        if (!resp.ok) {
            const msg = data.error?.message || 'Unbekannter Fehler';
            throw new Error(`Gemini-Fehler (${resp.status}): ${msg}`);
        }
        const text = data.candidates?.[0]?.content?.parts?.[0]?.text || '';
        return text;
    }

    throw new Error('Unbekannter KI-Anbieter f√ºr Audio-Transkription.');
}
// 
// 


// Hook in nach DOMContentLoaded (wurde in main-script verschoben)
// document.addEventListener('DOMContentLoaded', initIOSFallback);

</script>
<script>

// ---- MediaRecorder Fallback (Desktop): Direktaufnahme am PC ----
let __mr, __mrStream, __mrChunks = [], __mrRecording = false;

function setPcRecStatus(txt){ const s=document.getElementById('pcRecordStatus'); if(s) s.textContent = txt || ''; }
function stopStream(stream){ try{ if(stream) stream.getTracks().forEach(t=>t.stop()); }catch(_){} }

function initMediaRecorderFallback(){
    // Diagnose-Log hinzuf√ºgen, um zu sehen, ob die Funktion aufgerufen wird
    try { if(window.__memotag?.diag) __memotag.diag.diagLog('Init: MediaRecorder Fallback (PC Aufnahme)'); } catch(_) {}

    const btn = document.getElementById('pcRecordBtn');
    if(!btn) return;
    const supported = !!(navigator.mediaDevices && window.MediaRecorder);
    // Auf iOS ausblenden (wir verwenden dort den nativen Aufnahme-Dialog via <input capture>)
    if(!supported || isIOS()){
        if (btn) btn.style.display = 'none'; // Wenn der Browser es nicht kann oder es iOS ist, ausblenden.
        return;
    }
    btn.addEventListener('click', async () => {
        // Diagnose-Log hinzuf√ºgen
        try { if(window.__memotag?.diag) __memotag.diag.diagLog('Klick: PC Direkt aufnehmen'); } catch(_) {}

        if(!__mrRecording){
            try{
                // Erfrage Mikrofon-Berechtigung
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                __mrStream = stream;
                
                // W√§hle den besten MIME-Type
                const mime = MediaRecorder.isTypeSupported('audio/webm') ? 'audio/webm' :
                             (MediaRecorder.isTypeSupported('audio/ogg') ? 'audio/ogg' : 
                             (MediaRecorder.isTypeSupported('audio/mp4') ? 'audio/mp4' : ''));

                if (!mime) {
                    showError('Ihr Browser unterst√ºtzt keine MediaRecorder-Formate f√ºr Audio.');
                    stopStream(__mrStream);
                    return;
                }

                __mr = new MediaRecorder(stream, { mimeType: mime });
                __mrChunks = [];
                __mr.ondataavailable = e => { 
                    if(e.data && e.data.size > 0) {
                        __mrChunks.push(e.data); 
                        try { if(window.__memotag?.diag) __memotag.diag.diagLog(`Recorder: Chunk (${e.data.size} Bytes)`); } catch(_) {}
                    }
                };
                
                __mr.onerror = (e) => {
                    showError('Aufnahmefehler: ' + e.error.name);
                    try { if(window.__memotag?.diag) __memotag.diag.diagError('MediaRecorder Fehler: ' + e.error.name); } catch(_) {}
                    stopStream(__mrStream);
                    __mrRecording = false;
                    if(btn){ btn.textContent = 'PC: Direkt aufnehmen'; }
                    setPcRecStatus('Fehler.');
                };

                __mr.onstop = async () => {
                    try{
                        stopStream(__mrStream);
                        const blobType = __mr && __mr.mimeType ? __mr.mimeType : 'audio/webm';
                        const blob = new Blob(__mrChunks, { type: blobType });
                        const file = new File([blob], 'aufnahme.' + (blobType.includes('ogg') ? 'ogg' : 'webm'), { type: blobType });
                        
                        try { if(window.__memotag?.diag) __memotag.diag.diagLog(`Recorder Stopp: Datei (${file.name}) bereit. Gr√∂√üe: ${(file.size / 1024 / 1024).toFixed(2)} MB`); } catch(_) {}

                        // NEU: Zus√§tzliche Statusmeldung vor dem Senden an KI
                        document.getElementById('status').textContent = 'Audio-Datei gesendet. Warte auf KI-Transkription...';
                        setPcRecStatus('Sende an KI...'); // Zeige Status direkt am Knopf

                        const apiKey = document.getElementById('apiKey').value.trim();
                        const provider = document.getElementById('apiProvider').value;
                        if(!apiKey){ 
                            showError('Bitte gib einen API-Schl√ºssel ein.'); 
                            document.getElementById('status').textContent = 'Bereit zur Aufnahme';
                            return; 
                        }
                        const txt = await transcribeAudio(file, apiKey, provider);
                        currentTranscript = txt || '';
                        
                        // NEU: Logs f√ºr erfolgreichen Abschluss
                        try { if(window.__memotag?.diag) __memotag.diag.diagLog('Transkription erfolgreich abgeschlossen.'); } catch(_) {}

                        const t = document.getElementById('transcript'); if(t) t.value = currentTranscript;
                        const ts = document.getElementById('transcriptSection'); if(ts) ts.classList.add('show');
                        document.getElementById('status').textContent = 'Transkription abgeschlossen';
                        setPcRecStatus('Fertig!');

                    }catch(err){
                        // NEU: Bessere Fehlerbehandlung f√ºr KI-Transkription
                        const errorMessage = 'Transkription fehlgeschlagen: ' + (err.message || err);
                        showError(errorMessage);
                        try { if(window.__memotag?.diag) __memotag.diag.diagError(errorMessage); } catch(_) {}
                        document.getElementById('status').textContent = 'Bereit zur Aufnahme';
                        setPcRecStatus('Fehler.');
                    } finally {
                        __mrRecording = false;
                        if(btn){ btn.textContent = 'PC: Direkt aufnehmen'; }
                        // setPcRecStatus wird bereits in den catch/success Bl√∂cken gesetzt
                    }
                };

                __mr.start(500); // sammle alle 500ms Chunks
                __mrRecording = true;
                btn.textContent = 'Stopp (PC-Aufnahme)';
                setPcRecStatus('Aufnahme l√§uft‚Ä¶');
                try { if(window.__memotag?.diag) __memotag.diag.diagLog('Recorder gestartet: ' + mime); } catch(_) {}

            }catch(err){
                // Dies f√§ngt Fehler bei der Berechtigungsanfrage ab (z.B. "NotAllowedError")
                const errMsg = err.name === 'NotAllowedError' ? 'Mikrofonzugriff verweigert.' : (err.message || err);
                showError('Zugriff auf Mikrofon fehlgeschlagen: ' + errMsg);
                try { if(window.__memotag?.diag) __memotag.diag.diagError('Mic-Zugriff Fehler: ' + errMsg); } catch(_) {}
            }
        } else {
            // Stopp-Logik
            try{ 
                __mr.stop(); 
                try { if(window.__memotag?.diag) __memotag.diag.diagLog('Recorder Stopp-Kommando gesendet. Warte auf onstop Event...'); } catch(_) {}
                setPcRecStatus('Verarbeite...');
            }catch(_){}
            stopStream(__mrStream);
        }
    });
}

// Hook in nach DOMContentLoaded (wurde in main-script verschoben)
// document.addEventListener('DOMContentLoaded', initMediaRecorderFallback);

</script>
</body>
</html>
